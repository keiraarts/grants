{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport mongoose from \"mongoose\";\nvar MONGODB_URI = process.env.MONGO;\n\nif (!MONGODB_URI) {\n  throw new Error(\"Please define the MONGODB_URI environment variable inside .env.local\");\n}\n/**\n * Global is used here to maintain a cached connection across hot reloads\n * in development. This prevents connections growing exponentially\n * during API Route usage.\n */\n\n\nvar cached = global.mongoose;\n\nif (!cached) {\n  cached = global.mongoose = {\n    conn: null,\n    promise: null\n  };\n}\n\nfunction dbConnect() {\n  return _dbConnect.apply(this, arguments);\n}\n\nfunction _dbConnect() {\n  _dbConnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var opts;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!cached.conn) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\", cached.conn);\n\n          case 2:\n            if (!cached.promise) {\n              opts = {\n                useNewUrlParser: true,\n                useUnifiedTopology: true,\n                bufferCommands: false,\n                bufferMaxEntries: 0,\n                useFindAndModify: false,\n                useCreateIndex: true\n              };\n              cached.promise = mongoose.connect(MONGODB_URI, opts).then(function (mongoose) {\n                return mongoose;\n              });\n            }\n\n            _context.next = 5;\n            return cached.promise;\n\n          case 5:\n            cached.conn = _context.sent;\n            return _context.abrupt(\"return\", cached.conn);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _dbConnect.apply(this, arguments);\n}\n\nexport default dbConnect;","map":{"version":3,"sources":["/Users/kirilclimson/grants/utils/dbConnect.js"],"names":["mongoose","MONGODB_URI","process","env","MONGO","Error","cached","global","conn","promise","dbConnect","opts","useNewUrlParser","useUnifiedTopology","bufferCommands","bufferMaxEntries","useFindAndModify","useCreateIndex","connect","then"],"mappings":";;AAAA,OAAOA,QAAP,MAAqB,UAArB;AAEA,IAAMC,WAAW,GAAGC,OAAO,CAACC,GAAR,CAAYC,KAAhC;;AAEA,IAAI,CAACH,WAAL,EAAkB;AAChB,QAAM,IAAII,KAAJ,CACJ,sEADI,CAAN;AAGD;AAED;AACA;AACA;AACA;AACA;;;AACA,IAAIC,MAAM,GAAGC,MAAM,CAACP,QAApB;;AAEA,IAAI,CAACM,MAAL,EAAa;AACXA,EAAAA,MAAM,GAAGC,MAAM,CAACP,QAAP,GAAkB;AAAEQ,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,OAAO,EAAE;AAAvB,GAA3B;AACD;;SAEcC,S;;;;;wEAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBACMJ,MAAM,CAACE,IADb;AAAA;AAAA;AAAA;;AAAA,6CAEWF,MAAM,CAACE,IAFlB;;AAAA;AAKE,gBAAI,CAACF,MAAM,CAACG,OAAZ,EAAqB;AACbE,cAAAA,IADa,GACN;AACXC,gBAAAA,eAAe,EAAE,IADN;AAEXC,gBAAAA,kBAAkB,EAAE,IAFT;AAGXC,gBAAAA,cAAc,EAAE,KAHL;AAIXC,gBAAAA,gBAAgB,EAAE,CAJP;AAKXC,gBAAAA,gBAAgB,EAAE,KALP;AAMXC,gBAAAA,cAAc,EAAE;AANL,eADM;AAUnBX,cAAAA,MAAM,CAACG,OAAP,GAAiBT,QAAQ,CAACkB,OAAT,CAAiBjB,WAAjB,EAA8BU,IAA9B,EAAoCQ,IAApC,CAAyC,UAACnB,QAAD,EAAc;AACtE,uBAAOA,QAAP;AACD,eAFgB,CAAjB;AAGD;;AAlBH;AAAA,mBAmBsBM,MAAM,CAACG,OAnB7B;;AAAA;AAmBEH,YAAAA,MAAM,CAACE,IAnBT;AAAA,6CAoBSF,MAAM,CAACE,IApBhB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAuBA,eAAeE,SAAf","sourcesContent":["import mongoose from \"mongoose\";\n\nconst MONGODB_URI = process.env.MONGO;\n\nif (!MONGODB_URI) {\n  throw new Error(\n    \"Please define the MONGODB_URI environment variable inside .env.local\"\n  );\n}\n\n/**\n * Global is used here to maintain a cached connection across hot reloads\n * in development. This prevents connections growing exponentially\n * during API Route usage.\n */\nlet cached = global.mongoose;\n\nif (!cached) {\n  cached = global.mongoose = { conn: null, promise: null };\n}\n\nasync function dbConnect() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    const opts = {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n      bufferCommands: false,\n      bufferMaxEntries: 0,\n      useFindAndModify: false,\n      useCreateIndex: true,\n    };\n\n    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {\n      return mongoose;\n    });\n  }\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n\nexport default dbConnect;\n"]},"metadata":{},"sourceType":"module"}